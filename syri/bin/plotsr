#!/usr/bin/env python3

import argparse

"""
Annotation BED file format:

Chromosome ID
0-based start
1-based end
Genome (R/Q)
Marker (As defined here: https://matplotlib.org/stable/api/markers_api.html)
Marker colour (Name or hexadecimal)
Marker size
Annotations text
Annotations text color (Name or hexadecimal)
Annotations text size
"""

MARKERS={".": "point",
         ",": "pixel",
         "o": "circle",
         "v": "triangle_down",
         "^": "triangle_up",
         "<": "triangle_left",
         ">": "triangle_right",
         "1": "tri_down",
         "2": "tri_up",
         "3": "tri_left",
         "4": "tri_right",
         "8": "octagon",
         "s": "square",
         "p": "pentagon",
         "P": "plus (filled)",
         "*": "star",
         "h": "hexagon1",
         "H": "hexagon2",
         "+": "plus",
         "x": "x",
         "X": "x (filled)",
         "D": "diamond",
         "d": "thin_diamond",
         "|": "vline",
         "_": "hline",
         "i0": "tickleft",
         "i1": "tickright",
         "i2": "tickup",
         "i3": "tickdown",
         "i4": "caretleft",
         "i5": "caretright",
         "i6": "caretup",
         "i7": "caretdown",
         "i8": "caretleft (centered at base)",
         "i9": "caretright (centered at base)",
         "i10": "caretup (centered at base)",
         "i11": "caretdown"}

def filterinput(args, df, reflenghts, chrid_dict):
    # Get region length and filter out smaller SR
    df = df.loc[((df[2] - df[1]) >= args.s) | ((df[7] - df[6]) >= args.s) | (df[10]=='SYN')]
    df = df.loc[df[5] == [chrid_dict[i] for i in df[0]]]

    # Filter non-selected variations
    from warnings import warn
    if args.nosyn:
        df = df.loc[df[10] != 'SYN']
    if args.noinv:
        df = df.loc[df[10] != 'INV']
    if args.notr:
        df = df.loc[~df[10].isin(['TRANS', 'INVTR'])]
    if args.nodup:
        df = df.loc[~df[10].isin(['DUP', 'INVDP'])]
    if args.chr is not None:
        for chr in args.chr:
            if chr not in list(reflenghts.keys()):
                warn('Selected chromosome ID: {} is not present in the reference genome. Only use reference chromsome ID for selecting chromsomes.'.format(chr))
        df = df.loc[df[0].isin(args.chr)]
    return df


def createribbon(df):
    """
    Combine continuous syntenic regions to get larger ribbons for syntenic blocks
    """

    df.sort_values([5, 6, 7], inplace=True)
    df['b'] = list(range(df.shape[0]))
    df.sort_values([0, 1, 2], inplace=True)
    df['a'] = list(range(df.shape[0]))

    # Group syntenic regions
    groups = deque()
    cg = deque()
    ca = -1
    cb = -1
    issyn = list(df[10] == 'SYN')
    a = list(df['a'])
    b = list(df['b'])
    chrchange = np.where((np.array(df[0][1:]) == np.array(df[0][0:-1])) == False)[0] + 1
    for i in range(df.shape[0]):
        if i in chrchange:
            if len(cg) > 0:
                groups.append(list(cg))
            cg = deque()
            if issyn[i]:
                cg.append(i)
                ca = i
                cb = i
        elif not issyn[i]:
            if len(cg) > 0:
                groups.append(list(cg))
            cg = deque()
        else:
            if len(cg) == 0:
                cg.append(i)
                ca = i
                cb = i
            elif i == ca+1 and i == cb+1:
                cg.append(i)
                ca = i
                cb = i
            else:
                if len(cg)>0:
                    groups.append(list(cg))
                cg = deque()
                cg.append(i)
                ca = i
                cb = i
    if len(cg)>0:
        groups.append(list(cg))

    newsyn = deque()
    for i in groups:
        tmpdf = df.iloc[i]
        newsyn.append([
            list(tmpdf[0])[0],
            list(tmpdf[1])[0],
            list(tmpdf[2])[-1],
            list(tmpdf[5])[0],
            list(tmpdf[6])[0],
            list(tmpdf[7])[-1]
        ])
    newsyn = DataFrame(list(newsyn), columns=[0, 1, 2, 5, 6, 7])
    newsyn[10] = 'SYN'

    df = df.drop(['a', 'b'], axis=1)
    df = df.loc[-(df[10] == 'SYN')]
    df = df.append(newsyn)
    df.sort_values([0, 1, 2], inplace=True)
    return df


def drawax(ax, chrid_dict, reflenghts, qrylenghts, V, S, chrs):
    nchr = len(chrs)
    qchrs = [chrid_dict[k] for k in chrs]
    tick_pos = 1 - (S/2)
    ticklabels = chrs
    max_l = np.max([v for k, v in reflenghts.items() if k in chrs] + [v for k,v in qrylenghts.items() if k in qchrs])
    if not V:
        ax.set_ylim(0, nchr+0.2)
        ax.set_yticks([tick_pos+i for i in range(nchr)])
        ax.set_yticklabels(ticklabels[::-1])
        ax.tick_params(axis='y', right=False, left=False)
        ax.set_xlim(0, max_l)
        ax.ticklabel_format(axis='x', useOffset=False, style='plain')
        xticks = ax.get_xticks()
        if max_l >= 1000000000:
            xticks = xticks/1000000000
            ax.set_xlabel('chromosome position (in Gbp)')
        elif max_l >= 1000000:
            xticks = xticks/1000000
            ax.set_xlabel('chromosome position (in Mbp)')
        elif max_l >= 1000:
            xticks = xticks/1000
            ax.set_xlabel('chromosome position (in Kbp)')
        ax.set_xticklabels(xticks)
        ax.set_ylabel('reference chromosome id')
        ax.xaxis.grid(True, which='major', linestyle='--')
        ax.set_axisbelow(True)
    else:
        ax.set_xlim(0, nchr+0.2)
        ax.set_xticks([tick_pos+i for i in range(nchr)])
        ax.set_xticklabels(ticklabels)
        ax.tick_params(axis='x', top=False, bottom=False)
        ax.set_ylim(0, max_l)
        ax.ticklabel_format(axis='y', useOffset=False, style='plain')
        yticks = ax.get_yticks()
        if max_l >= 1000000000:
            yticks = yticks/1000000000
            ax.set_ylabel('chromosome position (in Gbp)')
        elif max_l >= 1000000:
            yticks = yticks/1000000
            ax.set_ylabel('chromosome position (in Mbp)')
        elif max_l >= 1000:
            yticks = yticks/1000
            ax.set_ylabel('chromosome position (in Kbp)')
        ax.set_yticklabels(yticks)
        ax.set_xlabel('reference chromosome id')
        ax.yaxis.grid(True, which='major', linestyle='--')
        ax.set_axisbelow(True)
    return ax, max_l


class bedanno():
    def __init__(self, chr, start, end, genome, V):
        self.chr = chr
        self.start = int(start)
        self.end = int(end)
        if genome in ['R', 'Q']: self.genome = genome
        else: print("Incorrect genome for position {}:{}-{}. Setting marker to line".format(self.start, self.start, self.end))
        self.V = V

    def setmarker(self, mtype, mcol, msize):
        if mtype not in MARKERS.keys():
            print("Unrecongised marker used for position {}:{}-{}. Plotsr accepts markers defined in matplotlib (https://matplotlib.org/stable/api/markers_api.html) with some modifications.".format(self.start, self.start, self.end))
            for k, v in MARKERS.items():
                print("{} : {}".format(k, v))
            sys.exit()
        self.mtype = mtype if mtype[0] != i else int(mtype[1:])

        try:
            if mcol[0] == '#':
                matplotlib.colors.to_rgb(mcol)
            else:
                matplotlib.colors.to_hex(mcol)
        except ValueError as e:
            print("Error in using colour: {} for position {}:{}-{}. Use correct hexadecimal colours or named colours define in matplotlib (https://matplotlib.org/stable/gallery/color/named_colors.html)".format(mcol, self.start, self.start, self.end))
            sys.exit()
        self.mcol = mcol
        self.msize = int(msize)
        if self.end - self.start > 1:
            print("Range selected for position {}:{}-{}. Setting marker to line".format(self.start, self.start, self.end))
            self.mtype = "|" if self.V else "_"

    def settext(self, text, col, size):
        self.text = text
        try:
            if col[0] == '#':
                matplotlib.colors.to_rgb(col)
            else:
                matplotlib.colors.to_hex(col)
        except ValueError as e:
            print("Error in using colour: {} for position {}:{}-{}. Use correct hexadecimal colours or named colours define in matplotlib (https://matplotlib.org/stable/gallery/color/named_colors.html)".format(col, self.start, self.start, self.end))
            sys.exit()
        self.col = col
        self.size = int(size)


def readbed(path, V):
    mdata = deque()
    with open(path, 'r') as fin:
        for line in fin:
            line = line.strip().split("\t")
            if len(line) not in [7, 10]:
                print(line)
                print("Incomplete data in BED file line: \n {}.\n Marker information (type, col, size) is necessary. Text annotation (text, col, size) is optional".format('\t'.join(line)))
                continue
            anno = bedanno(line[0], line[1], line[2], line[3], V)
            anno.setmarker(line[4], line[5], line[6])
            if len(line) > 7:
                anno.settext(line[7], line[8], line[9])
            mdata.append(anno)
    return mdata


def bezierpath(rs, re, qs, qe, ry, qy, V, col, alpha, label='', lw=0 ):
    # 4395  Chr4   1612606   2782625  Chr4   2891784   1739752  INV  1505  1505
    # 1612606, 2782625, 2891784, 1739752, rindent-offset, qindent-offset, V, col="black", alpha=alpha, lw=0.1
    # rs = 1612606
    # re = 2782625
    # qs = 2891784
    # qe = 1739752
    # ry = 1
    # qy = 2


    smid = (qs-rs)/2    # Start increment
    emid = (qe-re)/2    # End increment
    hmid = (qy-ry)/2    # Heinght increment

    if not V:
        verts = [(rs, ry),
                 (rs, ry+hmid),
                 (rs+2*smid, ry+hmid),
                 (rs+2*smid, ry+2*hmid),
                 (qe, qy),
                 (qe, qy-hmid),
                 (qe-2*emid, qy-hmid),
                 (qe-2*emid, qy-2*hmid),
                 (rs, ry),]

    else:
        verts = [(ry, rs),
                 (ry+hmid, rs),
                 (ry+hmid, rs+2*smid),
                 (ry+2*hmid, rs+2*smid),
                 (qy, qe),
                 (qy-hmid, qe),
                 (qy-hmid, qe-2*emid),
                 (qy-2*hmid, qe-2*emid),
                 (ry, rs),
                 ]

    codes = [
        Path.MOVETO,
        Path.CURVE4,
        Path.CURVE4,
        Path.CURVE4,
        Path.LINETO,
        Path.CURVE4,
        Path.CURVE4,
        Path.CURVE4,
        Path.CLOSEPOLY,
    ]

    path = Path(verts, codes)

    # fig, ax = plt.subplots()
    patch = patches.PathPatch(path, facecolor=col, lw=lw, alpha=alpha, label=label, edgecolor=col)
    # patch = patches.PathPatch(path) #, facecolor=col, lw=lw, alpha=alpha, label=label, linecolor=c)
    # ax.set_xlim(-0.1, 2.5)
    # ax.set_ylim(-0.1, 2991784)
    # ax.add_patch(patch)

    return patch


if __name__ == '__main__':
    from matplotlib.rcsetup import non_interactive_bk as bklist
    parser = argparse.ArgumentParser("Arguments for plotting SRs predicted by SyRI",
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(dest='reg', help='syri.out file generated by SyRI', type=argparse.FileType('r'))
    parser.add_argument(dest='r', help='path to reference genome', type=argparse.FileType('r'))
    parser.add_argument(dest='q', help='path to query genome', type=argparse.FileType('r'))
    parser.add_argument('-B', help='Annotation bed file for marking specific positions on genome', type=argparse.FileType('r'))
    parser.add_argument('--chr', help='Select reference chromosomes to be plotted. By default: all chromosomes are printed.', type=str, nargs='+')
    parser.add_argument('--nosyn', help='Do not plot syntenic regions', default=False, action='store_true')
    parser.add_argument('--noinv', help='Do not plot inversions', default=False, action='store_true')
    parser.add_argument('--notr', help='Do not plot translocations regions', default=False, action='store_true')
    parser.add_argument('--nodup', help='Do not plot duplications regions', default=False, action='store_true')
    parser.add_argument('-s', help='minimum size of a SR to be plotted', type=int, default=10000)
    parser.add_argument('-R', help='Create ribbons', default=False, action="store_true")
    parser.add_argument('-f', help='font size', type=int, default=6)
    parser.add_argument('-H', help='height of the plot', type=int)
    parser.add_argument('-W', help='width of the plot', type=int)
    parser.add_argument('-S', help='Space between homologous chromosome (0.1-0.9). Adjust this to make more space for annotation marker/text.', default=0.7, type=float)
    parser.add_argument('-o', help='output file format (pdf, png, svg)', default="pdf", choices=['pdf', 'png', 'svg'])
    parser.add_argument('-d', help='DPI for the final image', default="300", type=int)
    parser.add_argument('-b', help='Matplotlib backend to use', default="agg", type=str, choices=bklist)
    parser.add_argument('-v', help='Plot vertical chromosome', default=False, action='store_true')

    args = parser.parse_args()

    # CONSTANTS
    VARS = ['SYN', 'INV', 'TRANS', 'INVTR', 'DUP', 'INVDP']
    COLORS = ['#DEDEDE', '#FFA500', '#9ACD32', '#9ACD32', '#00BBFF', '#00BBFF', '#83AAFF', '#FF6A33']

    # Set Figure height and width. Change later based on chromosome number and size
    FS = args.f             # Font size
    H = args.H              # Height
    W = args.W              # Width
    O = args.o              # Output file format
    D = args.d              # Output file DPI
    R = args.R              # Create ribbons
    V = args.v              # Vertical chromosomes
    S = args.S              # Space between homologous chromosomes
    B = None if args.B is None else args.B.name              # Annotation bed file

    if S<0.1 or S>0.9:
        sys.exit('Out of range value for S. Please provide a value in the range 0.1-0.9')

    from Bio.SeqIO import parse
    reflenghts = {i.id: len(i.seq) for i in parse(args.r.name, 'fasta')}
    qrylenghts = {i.id: len(i.seq) for i in parse(args.q.name, 'fasta')}

    from collections import deque, OrderedDict
    syri_regs = deque()
    # with open(args.reg.name, 'r') as fin:
    with open(args.reg.name, 'r') as fin:
        for line in fin:
            l = line.strip().split()
            if l[10] in VARS:
                syri_regs.append(l)

    from pandas import DataFrame, concat
    import numpy as np

    df = DataFrame(list(syri_regs))[[0, 1, 2, 5, 6, 7, 10]]
    df[[0, 5, 10]] = df[[0, 5, 10]].astype(str)
    df[[1, 2, 6, 7]] = df[[1, 2, 6, 7]].astype(int)

    # chr ID map
    chrid = []
    chrid_dict = OrderedDict()
    for i in np.unique(df[0]):
        chrid.append((i, np.unique(df.loc[(df[0] == i) & (df[10] == 'SYN'), 5])[0]))
        chrid_dict[i] = np.unique(df.loc[(df[0] == i) & (df[10] == 'SYN'), 5])[0]

    # Check chromsome IDs and sizes

    # Reference genome
    for i in np.unique(df[0]):
        if i not in list(reflenghts.keys()):
            raise SystemExit('Chromosome ID ' + i + ' not present in reference genome. Exiting.')
        if np.max(np.max(df.loc[df[0] == i, [1, 2]])) > reflenghts[i]:
            raise SystemExit('For chromosome ID ' + i + ' in reference genome, max coordinate in syri.out is more than length of chromosome. Exiting.')

    # Query genome
    for i in np.unique(df[5]):
        if i not in list(qrylenghts.keys()):
            raise SystemExit('Chromosome ID ' + i + ' not present in query genome. Exiting.')
        if np.max(np.max(df.loc[df[5] == i, [6, 7]])) > qrylenghts[i]:
            raise SystemExit('For chromosome ID ' + i + ' in query genome, max coordinate in syri.out is more than length of chromosome. Exiting.')

    df = filterinput(args, df, reflenghts, chrid_dict)

    df.sort_values([5, 6, 7], inplace=True)
    df.sort_values([0, 1, 2], inplace=True)


    # Combine Ribbon is selected than combine rows
    if R: df = createribbon(df)

    # invert coord for inverted query genome
    invindex = ['INV' in i for i in df[10]]
    df.loc[invindex, 6] = df.loc[invindex, 6] + df.loc[invindex, 7]
    df.loc[invindex, 7] = df.loc[invindex, 6] - df.loc[invindex, 7]
    df.loc[invindex, 6] = df.loc[invindex, 6] - df.loc[invindex, 7]
    chrs = [k for k in chrid_dict.keys() if k in df[0].unique()]

    import matplotlib
    try:
        matplotlib.use(args.b)
        # matplotlib.use('Qt5Agg')
    except:
        sys.exit('Matplotlib backend cannot be selected')
    from matplotlib import pyplot as plt
    import matplotlib.patches as patches
    from matplotlib.path import Path

    plt.rcParams['font.size'] = FS
    try:
        if H is None and W is None:
            H = len(chrid)
            W = 3
            fig = plt.figure(figsize=[W, H])
        if H is not None and W is None:
            fig = plt.figure(figsize=[H, H])
        if H is None and W is not None:
            fig = plt.figure(figsize=[W, W])
        if H is not None and W is not None:
            fig = plt.figure(figsize=[W, H])
    except Exception as e:
        sys.exit("Error in initiliazing figure. Try using a differnt backend." + '\n' + e.with_traceback())
    ax = fig.add_subplot(111, frameon=False)
    ax, max_l = drawax(ax, chrid_dict, reflenghts, qrylenghts, V, S, chrs)

    # Draw chromosomes
    adRefLab = False
    adQryLab = False
    adSynLab = False
    adInvLab = False
    adTraLab = False
    adDupLab = False

    # Plot chromosomes
    pltchr = ax.axhline if not V else ax.axvline
    if not V:
        rindent = len(chrs)-0.02
        qindent = len(chrs)-S-0.02
    elif V:
        rindent = 1-S-0.02
        qindent = 1-0.02

    for i in range(len(chrs)):
        offset = i if not V else -i
        if not adRefLab:
            pltchr(rindent-offset, 0, reflenghts[chrs[i]]/max_l, color=COLORS[6], linewidth=3, label='Reference')
            adRefLab = True
        else:
            pltchr(rindent-offset, 0, reflenghts[chrs[i]]/max_l, color=COLORS[6], linewidth=3)
        if not adQryLab:
            pltchr(qindent-offset, 0, qrylenghts[chrid_dict[chrs[i]]]/max_l, color=COLORS[7], linewidth=3, label='Query')
            adQryLab = True
        else:
            pltchr(qindent-offset, 0, qrylenghts[chrid_dict[chrs[i]]]/max_l, color=COLORS[7], linewidth=3)


    # Plot structural annotations
    alpha = 0.8
    for i in range(len(chrs)):
        offset = i if not V else -i
        # Plot syntenic regions
        for row in df.loc[(df[0] == chrs[i]) & (df[10] == 'SYN')].itertuples(index=False):
            if not adSynLab:
                p = bezierpath(row[1], row[2], row[4], row[5], rindent-offset, qindent-offset, V, col=COLORS[0], alpha=alpha-0.2, label='Syntenic')
                adSynLab = True
            else:
                p = bezierpath(row[1], row[2], row[4], row[5], rindent-offset, qindent-offset, V, col=COLORS[0], alpha=alpha-0.2)
            ax.add_patch(p)

        # Plot Inversions
        for row in df.loc[(df[0] == chrs[i]) & (df[10] == 'INV')].itertuples(index=False):
            if not adInvLab:
                p = bezierpath(row[1], row[2], row[4], row[5], rindent-offset, qindent-offset, V, col=COLORS[1], alpha=alpha, label='Inversion', lw=0.1)
                adInvLab=True
            else:
                p = bezierpath(row[1], row[2], row[4], row[5], rindent-offset, qindent-offset, V, col=COLORS[1], alpha=alpha, lw=0.1)
            ax.add_patch(p)

        # Plot Translocations
        for row in df.loc[(df[0] == chrs[i]) & (df[10].isin(['TRANS', 'INVTR']))].itertuples(index=False):
            if not adTraLab:
                p = bezierpath(row[1], row[2], row[4], row[5], rindent-offset, qindent-offset, V, col=COLORS[2], alpha=alpha, label='Translocation', lw=0.1)
                adTraLab = True
            else:
                p = bezierpath(row[1], row[2], row[4], row[5], rindent-offset, qindent-offset, V, col=COLORS[2], alpha=alpha, lw=0.1)
            ax.add_patch(p)

        # Plot Duplications
        for row in df.loc[(df[0] == chrs[i]) & (df[10].isin(['DUP', 'INVDP']))].itertuples(index=False):
            if not adDupLab:
                p = bezierpath(row[1], row[2], row[4], row[5], rindent-offset, qindent-offset, V, col=COLORS[4], alpha=alpha, label='Duplication', lw=0.1)
                adDupLab=True
            else:
                p = bezierpath(row[1], row[2], row[4], row[5], rindent-offset, qindent-offset, V, col=COLORS[4], alpha=alpha, lw=0.1)
            ax.add_patch(p)

    ax.legend(loc='lower left', bbox_to_anchor=(0, 1.01, 1, 1.01), ncol=3, mode='expand', borderaxespad=0., frameon=False)
    
    # Plot markers
    if B is not None:
        mdata = readbed(B, V)
        for m in mdata:
            if not V:
                rindent = len(chrs)-0.02+0.1
                qindent = len(chrs)-0.02-S-0.1
                if m.genome == 'R':
                    offset = chrs.index(m.chr)
                    ax.plot(m.start, rindent-offset, marker=m.mtype, color=m.mcol, markersize=m.msize)
                    if hasattr(m, 'text'):
                        ax.text(m.start, rindent-offset+0.05, m.text, color=m.col, fontsize=m.size, ha='center', va='bottom')
                else:
                    offset = [j for j in range(len(chrs)) if chrid_dict[chrs[j]] == m.chr][0]
                    ax.plot(m.start, qindent-offset, marker=m.mtype, color=m.mcol, markersize=m.msize)
                    if hasattr(m, 'text'):
                        ax.text(m.start, qindent-offset-0.05, m.text, color=m.col, fontsize=m.size, ha='center', va='top')
            elif V:
                rindent = 1-S-0.02-0.1
                qindent = 1-0.02+0.1
                if m.genome == 'R':
                    offset = -chrs.index(m.chr)
                    ax.plot(rindent-offset, m.start, marker=m.mtype, color=m.mcol, markersize=m.msize)
                    if hasattr(m, 'text'):
                        ax.text(rindent-offset-0.05, m.start, m.text, color=m.col, fontsize=m.size, ha='right', va='center', rotation='vertical')
                else:
                    offset = -[j for j in range(len(chrs)) if chrid_dict[chrs[j]] == m.chr][0]
                    ax.plot(qindent-offset, m.start, marker=m.mtype, color=m.mcol, markersize=m.msize)
                    if hasattr(m, 'text'):
                        ax.text(qindent-offset+0.05, m.start, m.text, color=m.col, fontsize=m.size, ha='left', va='center', rotation='vertical')

    try:
        fig.savefig('syri.'+O, dpi=D, bbox_inches='tight', pad_inches=0.01)
    except Exception as e:
        sys.exit('Error in saving the figure. Try using a different backend.' + '\n' + e.with_traceback())
