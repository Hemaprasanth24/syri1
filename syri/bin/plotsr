#!/usr/bin/env python3

import argparse

if __name__ == '__main__':
    from matplotlib.rcsetup import non_interactive_bk as bklist
    parser = argparse.ArgumentParser("Arguments for plotting SRs predicted by SyRI")
    parser.add_argument(dest='reg', help='syri.out file generated by SyRI', type=argparse.FileType('r'))
    parser.add_argument(dest='r', help='path to reference genome', type=argparse.FileType('r'))
    parser.add_argument(dest='q', help='path to query genome', type=argparse.FileType('r'))
    parser.add_argument('-s', help='minimum size of a SR to be plotted', type=int, default=10000)
    parser.add_argument('-R', help='Create ribbons', default=False, action="store_true")
    parser.add_argument('-f', help='font size', type=int, default=6)
    parser.add_argument('-H', help='height of the plot', type=int)
    parser.add_argument('-W', help='width of the plot', type=int)
    parser.add_argument('-o', help='output file format (pdf, png, svg)', default="pdf", choices=['pdf', 'png', 'svg'])
    parser.add_argument('-d', help='DPI for the final image', default="300", type=int)
    parser.add_argument('-b', help='Matplotlib backend to use', default="agg", type=str, choices=bklist)

    args = parser.parse_args()

    # CONSTANTS
    VARS = ['SYN', 'INV', 'TRANS', 'INVTR', 'DUP', 'INVDP']
    COLORS = ['#DEDEDE', '#FFA500', '#9ACD32', '#9ACD32', '#00BBFF', '#00BBFF', '#83AAFF', '#FF6A33']

    # Set Figure height and width. Change later based on chromosome number and size
    FS = args.f
    H = args.H
    W = args.W
    O = args.o
    D = args.d
    R = args.R

    from Bio.SeqIO import parse
    reflenghts = {i.id: len(i.seq) for i in parse(args.r.name, 'fasta')}
    qrylenghts = {i.id: len(i.seq) for i in parse(args.q.name, 'fasta')}

    from collections import deque
    syri_regs = deque()
    # with open(args.reg.name, 'r') as fin:
    with open(args.reg.name, 'r') as fin:
        for line in fin:
            l = line.strip().split()
            if l[10] in VARS:
                syri_regs.append(l)

    from pandas import DataFrame, concat
    import numpy as np

    df = DataFrame(list(syri_regs))[[0, 1, 2, 5, 6, 7, 10]]
    df[[0, 5, 10]] = df[[0, 5, 10]].astype(str)
    df[[1, 2, 6, 7]] = df[[1, 2, 6, 7]].astype(int)

    # chr ID map
    chrid = []
    chrid_dict = {}
    for i in np.unique(df[0]):
        chrid.append((i, np.unique(df.loc[(df[0] == i) & (df[10] == 'SYN'), 5])[0]))
        chrid_dict[i] = np.unique(df.loc[(df[0] == i) & (df[10] == 'SYN'), 5])[0]

    # Check chromsome IDs and sizes

    # Reference genome
    for i in np.unique(df[0]):
        if i not in list(reflenghts.keys()):
            raise SystemExit('Chromosome ID ' + i + ' not present in reference genome. Exiting.')
        if np.max(np.max(df.loc[df[0] == i, [1, 2]])) > reflenghts[i]:
            raise SystemExit('For chromosome ID ' + i + ' in reference genome, max coordinate in syri.out is more than length of chromosome. Exiting.')

    # Query genome
    for i in np.unique(df[5]):
        if i not in list(qrylenghts.keys()):
            raise SystemExit('Chromosome ID ' + i + ' not present in query genome. Exiting.')
        if np.max(np.max(df.loc[df[5] == i, [6, 7]])) > qrylenghts[i]:
            raise SystemExit('For chromosome ID ' + i + ' in query genome, max coordinate in syri.out is more than length of chromosome. Exiting.')

    # Get region length and filter out smaller SR
    df = df.loc[((df[2] - df[1]) >= args.s) | ((df[7] - df[6]) >= args.s) | (df[10]=='SYN')]
    df = df.loc[df[5] == [chrid_dict[i] for i in df[0]]]

    df.sort_values([5, 6, 7], inplace=True)
    df['b'] = list(range(df.shape[0]))
    df.sort_values([0, 1, 2], inplace=True)
    df['a'] = list(range(df.shape[0]))

    # Combine Ribbon is selected than combine rows
    if R:
        # Group syntenic regions
        groups = deque()
        cg = deque()
        ca = -1
        cb = -1
        issyn = list(df[10] == 'SYN')
        a = list(df['a'])
        b = list(df['b'])
        chrchange = np.where((np.array(df[0][1:]) == np.array(df[0][0:-1])) == False)[0] + 1
        for i in range(df.shape[0]):
            if i in chrchange:
                if len(cg) > 0:
                    groups.append(list(cg))
                cg = deque()
                if issyn[i]:
                    cg.append(i)
                    ca = i
                    cb = i
            elif not issyn[i]:
                if len(cg) > 0:
                    groups.append(list(cg))
                cg = deque()
            else:
                if len(cg) == 0:
                    cg.append(i)
                    ca = i
                    cb = i
                elif i == ca+1 and i == cb+1:
                        cg.append(i)
                        ca = i
                        cb = i
                else:
                    if len(cg)>0:
                        groups.append(list(cg))
                    cg = deque()
                    cg.append(i)
                    ca = i
                    cb = i
        if len(cg)>0:
            groups.append(list(cg))

        newsyn = deque()
        for i in groups:
            tmpdf = df.iloc[i]
            newsyn.append([
                list(tmpdf[0])[0],
                list(tmpdf[1])[0],
                list(tmpdf[2])[-1],
                list(tmpdf[5])[0],
                list(tmpdf[6])[0],
                list(tmpdf[7])[-1]
            ])
        newsyn = DataFrame(list(newsyn), columns=[0, 1, 2, 5, 6, 7])
        newsyn[10] = 'SYN'

        df = df.drop(['a', 'b'], axis=1)
        df = df.loc[-(df[10] == 'SYN')]
        df = df.append(newsyn)
        df.sort_values([0, 1, 2], inplace=True)


    # invert coord for inverted query genome
    invindex = ['INV' in i for i in df[10]]
    df.loc[invindex, 6] = df.loc[invindex, 6] + df.loc[invindex, 7]
    df.loc[invindex, 7] = df.loc[invindex, 6] - df.loc[invindex, 7]
    df.loc[invindex, 6] = df.loc[invindex, 6] - df.loc[invindex, 7]

    
    import matplotlib
    try:
        matplotlib.use(args.b)
    except:
        sys.exit('Matplotlib backend cannot be selected')
    from matplotlib import pyplot as plt
    from matplotlib.patches import Polygon

    plt.rcParams['font.size'] = FS
    try:
        if H is None and W is None:
            H = len(chrid)
            W = 3
            fig = plt.figure(figsize=[W, H])
        if H is not None and W is None:
            fig = plt.figure(figsize=[H, H])
        if H is None and W is not None:
            fig = plt.figure(figsize=[W, W])
        if H is not None and W is not None:
            fig = plt.figure(figsize=[W, H])
    except Exception as e:
        sys.exit("Error in initiliazing figure. Try using a differnt backend." + '\n' + e.with_traceback())

    # fig = plt.figure(figsize=[W, H])
    ax = fig.add_subplot(111, frameon=False)
    ax.set_ylim(0, len(chrid)+0.2)
    ax.set_yticks([0.65+i for i in range(len(chrid))])
    ax.set_yticklabels([i[0] for i in chrid[::-1]])
    ax.tick_params(axis='y', right=False, left=False)
    max_x = np.max(list(reflenghts.values()) + list(qrylenghts.values()))
    ax.set_xlim(0, max_x)
    ax.ticklabel_format(axis='x', useOffset=False, style='plain')
    xticks = ax.get_xticks()
    if max_x >= 1000000000:
        xticks = xticks/1000000000
        ax.set_xlabel('chromosome position (in Gbp)')
    elif max_x >= 1000000:
        xticks = xticks/1000000
        ax.set_xlabel('chromosome position (in Mbp)')
    elif max_x >= 1000:
        xticks = xticks/1000
        ax.set_xlabel('chromosome position (in Kbp)')
    ax.set_xticklabels(xticks)

    # m = len(str(ax.get_xticks()[1]).split('.')[0])

    ax.set_ylabel('reference chromosome id')
    ax.xaxis.grid(True, which='major', linestyle='--')
    ax.set_axisbelow(True)

    # Draw chromosomes
    adRefLab = False
    adQryLab = False
    adSynLab = False
    adInvLab = False
    adTraLab = False
    adDupLab = False

    for i in range(len(chrid)):
        if not adRefLab:
            ax.axhline(len(chrid)-0.02-i, 0, reflenghts[chrid[i][0]]/max_x, color=COLORS[6], linewidth=3, label='Reference')
            adRefLab = True
        else:
            ax.axhline(len(chrid)-0.02-i, 0, reflenghts[chrid[i][0]]/max_x, color=COLORS[6], linewidth=3)

    for i in range(len(chrid)):
        if not adQryLab:
            ax.axhline(len(chrid)-0.02-i-0.7, 0, qrylenghts[chrid[i][1]]/max_x, color=COLORS[7], linewidth=3, label='Query')
            adQryLab = True
        else:
            ax.axhline(len(chrid)-0.02-i-0.7, 0, qrylenghts[chrid[i][1]]/max_x, color=COLORS[7], linewidth=3)

    alpha = 0.8
    for i in range(len(chrid)):
        # data
        for row in df.loc[(df[0] == chrid[i][0]) & (df[10] == 'SYN')].itertuples(index=False):
            if not adSynLab:
                p = Polygon(np.array([[row[1], len(chrid)-0.02-i],
                         [row[2], len(chrid)-0.02-i],
                         [row[5], len(chrid)-0.02-i-0.7],
                         [row[4], len(chrid)-0.02-i-0.7]]), closed=True, color=COLORS[0], alpha=alpha-0.2, linewidth=0, label='Syntenic')
                adSynLab = True
            else:
                p = Polygon(np.array([[row[1], len(chrid)-0.02-i],
                         [row[2], len(chrid)-0.02-i],
                         [row[5], len(chrid)-0.02-i-0.7],
                         [row[4], len(chrid)-0.02-i-0.7]]), closed=True, color=COLORS[0], alpha=alpha-0.2, linewidth=0)
            ax.add_patch(p)

        for row in df.loc[(df[0] == chrid[i][0]) & (df[10] == 'INV')].itertuples(index=False):
            if not adInvLab:
                p = Polygon(np.array([[row[1], len(chrid)-0.02-i],
                         [row[2], len(chrid)-0.02-i],
                         [row[5], len(chrid)-0.02-i-0.7],
                         [row[4], len(chrid)-0.02-i-0.7,]]), closed=True, color=COLORS[1], alpha=alpha, linewidth=0, label='Inversion')
                adInvLab=True
            else:
                p = Polygon(np.array([[row[1], len(chrid)-0.02-i],
                         [row[2], len(chrid)-0.02-i],
                         [row[5], len(chrid)-0.02-i-0.7],
                         [row[4], len(chrid)-0.02-i-0.7,]]), closed=True, color=COLORS[1], alpha=alpha, linewidth=0)
            ax.add_patch(p)

        for row in df.loc[(df[0] == chrid[i][0]) & (df[10].isin(['TRANS', 'INVTR']))].itertuples(index=False):
            if not adTraLab:
                p = Polygon(np.array([[row[1], len(chrid)-0.02-i],
                         [row[2], len(chrid)-0.02-i],
                         [row[5], len(chrid)-0.02-i-0.7],
                         [row[4], len(chrid)-0.02-i-0.7]]), closed=True, color=COLORS[2], alpha=alpha, linewidth=0, label='Translocation')
                adTraLab = True
            else:
                p = Polygon(np.array([[row[1], len(chrid)-0.02-i],
                         [row[2], len(chrid)-0.02-i],
                         [row[5], len(chrid)-0.02-i-0.7],
                         [row[4], len(chrid)-0.02-i-0.7]]), closed=True, color=COLORS[2], alpha=alpha, linewidth=0)
            ax.add_patch(p)

        for row in df.loc[(df[0] == chrid[i][0]) & (df[10].isin(['DUP', 'INVDP']))].itertuples(index=False):
            if not adDupLab:
                p = Polygon(np.array([[row[1], len(chrid)-0.02-i],
                         [row[2], len(chrid)-0.02-i],
                         [row[5], len(chrid)-0.02-i-0.7],
                         [row[4], len(chrid)-0.02-i-0.7]]), closed=True, color=COLORS[4], alpha=alpha, linewidth=0, label='Duplication')
                adDupLab=True
            else:
                p = Polygon(np.array([[row[1], len(chrid)-0.02-i],
                         [row[2], len(chrid)-0.02-i],
                         [row[5], len(chrid)-0.02-i-0.7],
                         [row[4], len(chrid)-0.02-i-0.7]]), closed=True, color=COLORS[4], alpha=alpha, linewidth=0)
            ax.add_patch(p)

    ax.legend(loc='lower left', bbox_to_anchor=(0, 1.01, 1, 1.01), ncol=3, mode='expand', borderaxespad=0., frameon=False)

    try:
        fig.savefig('syri.'+O, dpi=D, bbox_inches='tight', pad_inches=0.01)
    except Exception as e:
        sys.exit('Error in saving the figure. Try using a different backend.' + '\n' + e.with_traceback())

